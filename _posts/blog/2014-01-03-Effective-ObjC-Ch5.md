---
layout:    post
title:     Effective Objective-C 2.0 Chapter 5
category:  blog
description: 内存管理
tags: ObjC
---

# 第 5 章 内存管理
内存管理在任何如同 Objective-C 这样的面向对象语音中，都是一个重要概念。理解语言的内存管理模型的细节是写出内存高效，无 bug 代码的关键。

一旦你理解了这些规则，Objective-C 中内存管理也就并不复杂了，而且随着自动引用计数（ARC）的到来变得更加容易了。ARC 将几乎全部的内存管理决定转交给了编译器，使你可以专注于事物逻辑。


## 条目 29 ： 理解引用计数
* 引用计数内存管理基于计数器的增减。对象被创建时，计数器为 1。对象有正数的保留计数器值就是存活的。当保留计数器降为 0 时，对象被销毁。
* 对象被其他对象持有其引用而被保留或被释放，贯穿于整个生命周期。保留增加和释放减少计数器值。

## 条目 30 ： 使用 ARC 使引用技术更容易

ARC(Automatic Reference Counting) 自动引用计数。

### 方法名

ARC 之前，方法返回值的内存管理语义由方法名约定。ARC 固化了方法返回值的内存管理语义。

alloc, new, copy, mutableCopy 意味着对象的返回值为调用者所有。其他的方法名意味着任何被返回的对象将不被方法调用者所有。

### 变量
本地和实例变量的语义可以通过应用的以下标示符改变：

* __strong 缺省的；值会被保留。
* \_\_unsafe\_\_unretained 值不被保留，可能是不安全的。
* __weak 值不被保留，但是是安全的。因为如果当前对象一旦被释放，它就被自动设为 nil。
* __autoreleasing 这个特别的标示符在对象以参数传入方法时使用。值在返回时被 autoreleased。

* 自动引用计数（ARC）从开发者对内存管理工作的担忧中解救出来。使用 ARC 将减少重复模版代码。
* ARC 处理对象几乎整个生命周期，在其认为合适的地方添加 retians 和 releases。变量标示符可以用于指示内存管理语义；在此之前，retians 和 releases 需要手动添加。
* 方法名必须指明返回值的内存管理语义。ARC 固化了这些，并使得违反它们变得不可能。
* ARC 只处理 Objective-C 对象。实践中，这意味着 CoreFoundation 对象不会被处理，这样合适的 CFRetain/CFRelease 调用就是必须的了。
 

## 条目 31 ： 只在 dealloc 中释放引用和清除观察状态 
* 在 dealloc 方法应该只被用于释放对其他对象的引用和任何需要解除登记的地方，例如 键值观察（KVO）或者 NSNotificationCenter 通知。
* 如果一个对象持有系统资源，例如文件描述符，应该在 dealloc 内释放这些资源。这应该成为一个约定，这样的类的消费者在资源使用完之后，调用这个闭合方法。
* 试图执行异步任务的和在正常状态下执行消费对象的方法调用应该避免在 dealloc 中被调用。

## 条目 32 ： 小心异常安全代码的内存管理
* 当异常被捕捉时，应该小心取保所有在 try 中创建的对象的清理都完成了。
* 缺省的，ARC 没有放置处理当异常抛出时的清理工作。这可以通过一个编译器标志位打开，但是产品代码会变得更大，运行时的开销也更多。

## 条目 33 ： 使用弱引用避免引用循环
* 保留循环可以通过为特定的引用置 weak 避免。
* weak 引用可以被也可以不被自动置为 nil。自动置 nil 是 ARC 引入的新功能，并在运行时实现。自动置 nil 的 weak 引用是读安全的，他们不会包含一个已经销毁的对象的引用。

## 条目 34 ： 使用自动释放池代码块减低高内存峰值
* 自动释放池被置于栈中。当对象接收到自动释放消息时，对象会被加到最上面的池中。
* 正确的使用自动释放池可以帮助减少应用的高内存消耗瓶颈。
* 使用新的 @autoreleasepool 语法现代自动释放池消耗更低。

## 条目 35 ： 使用 Zombies 帮助调试内存管理问题
* 当一个对象要被消耗的时候，它可以选择性地置入 zombie 而不是真正被销毁。这个功能通过使用环境标识 NSZombieEnabled 开启。
* 一个对象通过操作其 isa 指针改变对象的类为特别的 zombie 类而被转入 zombie。一个 zombie 类对于所有选择器的反应都是推出应用而后打印一条表明什么消息发给什么对象的信息。

## 条目 36 ： 避免使用 retainCount

* 对象的 retain 计数器可能看起来很有用但是却不常用。因为在任何时候的绝对的 retain 计数都不能给出对象生命周期的完全图景。
* 当 ARC 开启时，retainCount 方法就被废弃了，使用它将会导致一个编译器错误产生。
 
 